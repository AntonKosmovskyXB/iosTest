import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { combineLatest } from 'rxjs';
import { DataTableService } from '../../services/data-table.service';
import { ScriptLoaderService } from '../../services/script-loader.service';
import { ControlWrapperComponent } from '../control-wrapper/control-wrapper.component';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
export class DashboardComponent {
    constructor(element, loaderService, dataTableService) {
        this.element = element;
        this.loaderService = loaderService;
        this.dataTableService = dataTableService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);
            this.createDashboard();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns || changes.formatters) {
            this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);
            this.dashboard.draw(this.dataTable);
        }
    }
    createDashboard() {
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);
        const chartsReady$ = this.controlWrappers
            .map(control => control.for)
            .map(charts => {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(chart => chart.wrapperReady$));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {
            this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);
            this.initializeBindings();
            this.registerEvents();
            this.dashboard.draw(this.dataTable);
        });
    }
    registerEvents() {
        google.visualization.events.removeAllListeners(this.dashboard);
        const registerDashEvent = (object, eventName, callback) => {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerDashEvent(this.dashboard, 'ready', () => this.ready.emit());
        registerDashEvent(this.dashboard, 'error', (error) => this.error.emit(error));
    }
    initializeBindings() {
        this.controlWrappers.forEach(control => {
            if (Array.isArray(control.for)) {
                const chartWrappers = control.for.map(chart => chart.chartWrapper);
                this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    }
}
DashboardComponent.ɵfac = function DashboardComponent_Factory(t) { return new (t || DashboardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScriptLoaderService), ɵngcc0.ɵɵdirectiveInject(DataTableService)); };
DashboardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DashboardComponent, selectors: [["dashboard"]], contentQueries: function DashboardComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ControlWrapperComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.controlWrappers = _t);
    } }, hostAttrs: [1, "dashboard"], inputs: { data: "data", columns: "columns", formatters: "formatters" }, outputs: { ready: "ready", error: "error" }, exportAs: ["dashboard"], features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function DashboardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DashboardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService },
    { type: DataTableService }
];
DashboardComponent.propDecorators = {
    data: [{ type: Input }],
    columns: [{ type: Input }],
    formatters: [{ type: Input }],
    ready: [{ type: Output }],
    error: [{ type: Output }],
    controlWrappers: [{ type: ContentChildren, args: [ControlWrapperComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DashboardComponent, [{
        type: Component,
        args: [{
                selector: 'dashboard',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'dashboard',
                host: { class: 'dashboard' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ScriptLoaderService }, { type: DataTableService }]; }, { ready: [{
            type: Output
        }], error: [{
            type: Output
        }], data: [{
            type: Input
        }], columns: [{
            type: Input
        }], formatters: [{
            type: Input
        }], controlWrappers: [{
            type: ContentChildren,
            args: [ControlWrapperComponent]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9hbmd1bGFyLWdvb2dsZS1jaGFydHMvc3JjL2xpYi9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFckMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDckUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFJM0UsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOENBQThDLENBQUM7Ozs7QUFTdkYsTUFBTSxPQUFPLGtCQUFrQjtBQUFHLElBbURoQyxZQUNVLE9BQW1CLEVBQ25CLGFBQWtDLEVBQ2xDLGdCQUFrQztBQUMzQyxRQUhTLFlBQU8sR0FBUCxPQUFPLENBQVk7QUFBQyxRQUNwQixrQkFBYSxHQUFiLGFBQWEsQ0FBcUI7QUFBQyxRQUNuQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0FBQzlDLFFBNUJFO0FBQ0Y7QUFFQztBQUFXO0FBQ007QUFDTTtBQUdaLFdBRlA7QUFDTCxRQUNTLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO0FBQzFDLFFBQ0U7QUFDRjtBQUNNO0FBRUEsV0FERDtBQUNMLFFBQ1MsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO0FBQ3JELFFBTVUsZ0JBQVcsR0FBRyxLQUFLLENBQUM7QUFDOUIsSUFLSyxDQUFDO0FBQ04sSUFDUyxRQUFRO0FBQ2pCLFFBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFB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Q1QsUUFBUSxFQUFFLFdBQVcsa0JBQ3JCLFFBQVEsRUFBRSwyQkFBMkIsa0JBQ3JDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNLGtCQUMvQztLQUFRLEVBQUUsV0FBVyxrQkFDckIsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxjQUM3Qjs7Ozs7Ozs7aURBQ0k7QUFBQztBQUE0QyxZQXpCaEQsVUFBVTtBQUNWLFlBV08sbUJBQW1CO0FBQUksWUFEdkIsZ0JBQWdCO0FBQUc7QUFBRztBQUFzQyxtQkFvQmxFLEtBQUs7QUFDTixzQkFRQyxLQUFLO0FBQ04seUJBUUMsS0FBSztBQUNOLG9CQVNDLE1BQU07QUFDUCxvQkFNQyxNQUFNO0FBQ1AsOEJBRUMsZUFBZSxTQUFDLHVCQUF1QjtBQUN0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEYXRhVGFibGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZGF0YS10YWJsZS5zZXJ2aWNlJztcbmltcG9ydCB7IFNjcmlwdExvYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zY3JpcHQtbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2hhcnRFcnJvckV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB7IEZvcm1hdHRlciB9IGZyb20gJy4uLy4uL3R5cGVzL2Zvcm1hdHRlcic7XG5pbXBvcnQgeyBDb2x1bW4sIFJvdyB9IGZyb20gJy4uL2NoYXJ0LWJhc2UvY2hhcnQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udHJvbFdyYXBwZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb250cm9sLXdyYXBwZXIvY29udHJvbC13cmFwcGVyLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Rhc2hib2FyZCcsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBleHBvcnRBczogJ2Rhc2hib2FyZCcsXG4gIGhvc3Q6IHsgY2xhc3M6ICdkYXNoYm9hcmQnIH1cbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuICAvKipcbiAgICogRGF0YSB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHRhYmxlLlxuICAgKlxuICAgKiBUaGlzIG11c3QgYWxzbyBjb250YWluIGFsbCByb2xlcyB0aGF0IGFyZSBzZXQgaW4gdGhlIGBjb2x1bW5zYCBwcm9wZXJ0eS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBkYXRhITogUm93W107XG5cbiAgLyoqXG4gICAqIFRoZSBjb2x1bW5zIHRoZSBgZGF0YWAgY29uc2lzdHMgb2YuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2YgZWFjaCByb3cgaW4gdGhlIGBkYXRhYCBvYmplY3QuXG4gICAqXG4gICAqIElmIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jaGFydC9pbnRlcmFjdGl2ZS9kb2NzL3JvbGVzIHJvbGVzfSBzaG91bGQgYmUgYXBwbGllZCwgdGhleSBtdXN0IGJlIGluY2x1ZGVkIGluIHRoaXMgYXJyYXkgYXMgd2VsbC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBjb2x1bW5zPzogQ29sdW1uW107XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2hhbmdlIHRoZSBkaXNwbGF5ZWQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBjb2x1bW4gaW4gYWxsIHJvd3MuXG4gICAqXG4gICAqIEVhY2ggYXJyYXkgZWxlbWVudCBtdXN0IGNvbnNpc3Qgb2YgYW4gaW5zdGFuY2Ugb2YgYSBbYGZvcm1hdHRlcmBdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3MvcmVmZXJlbmNlI2Zvcm1hdHRlcnMpXG4gICAqIGFuZCB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB5b3Ugd2FudCB0aGUgZm9ybWF0dGVyIHRvIGdldCBhcHBsaWVkIHRvLlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGZvcm1hdHRlcnM/OiBGb3JtYXR0ZXJbXTtcblxuICAvKipcbiAgICogVGhlIGRhc2hib2FyZCBoYXMgY29tcGxldGVkIGRyYXdpbmcgYW5kIGlzIHJlYWR5IHRvIGFjY2VwdCBjaGFuZ2VzLlxuICAgKlxuICAgKiBUaGUgcmVhZHkgZXZlbnQgd2lsbCBhbHNvIGZpcmU6XG4gICAqIC0gYWZ0ZXIgdGhlIGNvbXBsZXRpb24gb2YgYSBkYXNoYm9hcmQgcmVmcmVzaCB0cmlnZ2VyZWQgYnkgYSB1c2VyIG9yIHByb2dyYW1tYXRpYyBpbnRlcmFjdGlvbiB3aXRoIG9uZSBvZiB0aGUgY29udHJvbHMsXG4gICAqIC0gYWZ0ZXIgcmVkcmF3aW5nIGFueSBjaGFydCBvbiB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIHB1YmxpYyByZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiBhbiBlcnJvciBvY2N1cnMgd2hlbiBhdHRlbXB0aW5nIHRvIHJlbmRlciB0aGUgZGFzaGJvYXJkLlxuICAgKiBPbmUgb3IgbW9yZSBvZiB0aGUgY29udHJvbHMgYW5kIGNoYXJ0cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBkYXNoYm9hcmQgbWF5IGhhdmUgZmFpbGVkIHJlbmRlcmluZy5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBwdWJsaWMgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0RXJyb3JFdmVudD4oKTtcblxuICBAQ29udGVudENoaWxkcmVuKENvbnRyb2xXcmFwcGVyQ29tcG9uZW50KVxuICBwcml2YXRlIGNvbnRyb2xXcmFwcGVycyE6IFF1ZXJ5TGlzdDxDb250cm9sV3JhcHBlckNvbXBvbmVudD47XG5cbiAgcHJpdmF0ZSBkYXNoYm9hcmQ/OiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQ7XG4gIHByaXZhdGUgZGF0YVRhYmxlPzogZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVRhYmxlO1xuICBwcml2YXRlIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgbG9hZGVyU2VydmljZTogU2NyaXB0TG9hZGVyU2VydmljZSxcbiAgICBwcml2YXRlIGRhdGFUYWJsZVNlcnZpY2U6IERhdGFUYWJsZVNlcnZpY2VcbiAgKSB7fVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmxvYWRlclNlcnZpY2UubG9hZENoYXJ0UGFja2FnZXMoJ2NvbnRyb2xzJykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuZGF0YVRhYmxlID0gdGhpcy5kYXRhVGFibGVTZXJ2aWNlLmNyZWF0ZSh0aGlzLmRhdGEsIHRoaXMuY29sdW1ucywgdGhpcy5mb3JtYXR0ZXJzKTtcbiAgICAgIHRoaXMuY3JlYXRlRGFzaGJvYXJkKCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuZGF0YSB8fCBjaGFuZ2VzLmNvbHVtbnMgfHwgY2hhbmdlcy5mb3JtYXR0ZXJzKSB7XG4gICAgICB0aGlzLmRhdGFUYWJsZSA9IHRoaXMuZGF0YVRhYmxlU2VydmljZS5jcmVhdGUodGhpcy5kYXRhLCB0aGlzLmNvbHVtbnMsIHRoaXMuZm9ybWF0dGVycyk7XG4gICAgICB0aGlzLmRhc2hib2FyZCEuZHJhdyh0aGlzLmRhdGFUYWJsZSEpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGFzaGJvYXJkKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGhhcHBlbiBpbiB0aGUgY29udHJvbCB3cmFwcGVyXG4gICAgLy8gSG93ZXZlciwgSSBkb24ndCB5ZXQga25vdyBob3cgdG8gZG8gdGhpcyBiZWNhdXNlIHRoZW4gYGJpbmQoKWAgd291bGQgZ2V0IGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIGZvciB0aGUgc2FtZSBjb250cm9sIGlmIHNvbWV0aGluZyBjaGFuZ2VzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZ29vZ2xlIGNoYXJ0cyBhcyBmYXIgYXMgSSBjYW4gdGVsbFxuICAgIC8vIGZyb20gdGhlaXIgc291cmNlIGNvZGUuXG4gICAgY29uc3QgY29udHJvbFdyYXBwZXJzUmVhZHkkID0gdGhpcy5jb250cm9sV3JhcHBlcnMubWFwKGNvbnRyb2wgPT4gY29udHJvbC53cmFwcGVyUmVhZHkkKTtcbiAgICBjb25zdCBjaGFydHNSZWFkeSQgPSB0aGlzLmNvbnRyb2xXcmFwcGVyc1xuICAgICAgLm1hcChjb250cm9sID0+IGNvbnRyb2wuZm9yKVxuICAgICAgLm1hcChjaGFydHMgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFydHMpKSB7XG4gICAgICAgICAgLy8gQ29tYmluZUxhdGVzdCB3YWl0cyBmb3IgYWxsIG9ic2VydmFibGVzXG4gICAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoY2hhcnRzLm1hcChjaGFydCA9PiBjaGFydC53cmFwcGVyUmVhZHkkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0cy53cmFwcGVyUmVhZHkkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8vIFdlIGhhdmUgdG8gd2FpdCBmb3IgYWxsIGNoYXJ0IHdyYXBwZXJzIGFuZCBjb250cm9sIHdyYXBwZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgLy8gYmVmb3JlIHdlIGNhbiBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gY3JlYXRlIHRoZSBkYXNoYm9hcmRcbiAgICBjb21iaW5lTGF0ZXN0KFsuLi5jb250cm9sV3JhcHBlcnNSZWFkeSQsIC4uLmNoYXJ0c1JlYWR5JF0pLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmRhc2hib2FyZCA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgdGhpcy5pbml0aWFsaXplQmluZGluZ3MoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoKTtcbiAgICAgIHRoaXMuZGFzaGJvYXJkLmRyYXcodGhpcy5kYXRhVGFibGUhKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJFdmVudHMoKTogdm9pZCB7XG4gICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycyh0aGlzLmRhc2hib2FyZCk7XG5cbiAgICBjb25zdCByZWdpc3RlckRhc2hFdmVudCA9IChvYmplY3Q6IGFueSwgZXZlbnROYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikgPT4ge1xuICAgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLmFkZExpc3RlbmVyKG9iamVjdCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHJlZ2lzdGVyRGFzaEV2ZW50KHRoaXMuZGFzaGJvYXJkLCAncmVhZHknLCAoKSA9PiB0aGlzLnJlYWR5LmVtaXQoKSk7XG4gICAgcmVnaXN0ZXJEYXNoRXZlbnQodGhpcy5kYXNoYm9hcmQsICdlcnJvcicsIChlcnJvcjogQ2hhcnRFcnJvckV2ZW50KSA9PiB0aGlzLmVycm9yLmVtaXQoZXJyb3IpKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUJpbmRpbmdzKCk6IHZvaWQge1xuICAgIHRoaXMuY29udHJvbFdyYXBwZXJzLmZvckVhY2goY29udHJvbCA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sLmZvcikpIHtcbiAgICAgICAgY29uc3QgY2hhcnRXcmFwcGVycyA9IGNvbnRyb2wuZm9yLm1hcChjaGFydCA9PiBjaGFydC5jaGFydFdyYXBwZXIpO1xuICAgICAgICB0aGlzLmRhc2hib2FyZCEuYmluZChjb250cm9sLmNvbnRyb2xXcmFwcGVyLCBjaGFydFdyYXBwZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkIS5iaW5kKGNvbnRyb2wuY29udHJvbFdyYXBwZXIsIGNvbnRyb2wuZm9yLmNoYXJ0V3JhcHBlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==