import { __decorate, __metadata } from 'tslib';
import { Injectable, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { orientation } from 'exifr';
import Pica from 'pica';
import { switchMap } from 'rxjs/operators';

var NgxPicaErrorType;
(function (NgxPicaErrorType) {
    NgxPicaErrorType["NO_FILES_RECEIVED"] = "NO_FILES_RECEIVED";
    NgxPicaErrorType["CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED"] = "CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED";
    NgxPicaErrorType["NOT_BE_ABLE_TO_COMPRESS_ENOUGH"] = "NOT_BE_ABLE_TO_COMPRESS_ENOUGH";
    NgxPicaErrorType["READ_ERROR"] = "IMAGE_COULD_NOT_BE_LOADED";
})(NgxPicaErrorType || (NgxPicaErrorType = {}));

var NgxPicaExifService = /** @class */ (function () {
    function NgxPicaExifService() {
    }
    NgxPicaExifService.prototype.getExifOrientedImage = function (image) {
        return new Promise(function (resolve, reject) {
            orientation(image)
                .catch(function (err) {
                // IF SOMETHING WAS WRONG, WE RETURN ORIGINAL IMAGE
                resolve(image);
            })
                .then(function (exifOrientation) {
                if (exifOrientation && exifOrientation !== 1) {
                    if (exifOrientation < 1 || exifOrientation > 8) {
                        throw new Error('orientation should be [1-8]');
                    }
                    var canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
                    var deg = 0, cx = 0, cy = 0, width = image.width, height = image.height;
                    if ([5, 6, 7, 8].indexOf(exifOrientation) > -1) {
                        width = image.height;
                        height = image.width;
                    }
                    canvas.width = width;
                    canvas.height = height;
                    switch (exifOrientation) {
                        case 3:
                        case 4:
                            cx = -image.width;
                            cy = -image.height;
                            deg = 180;
                            break;
                        case 5:
                        case 6:
                            cy = -image.height;
                            deg = 90;
                            break;
                        case 7:
                        case 8:
                            cx = -image.width;
                            deg = 270;
                            break;
                        default:
                            break;
                    }
                    if ([2, 4, 5, 7].indexOf(exifOrientation) > -1) {
                        ctx.translate(width, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.rotate(deg / 180 * Math.PI);
                    ctx.drawImage(image, cx, cy);
                    var img_1 = new Image();
                    img_1.width = width;
                    img_1.height = height;
                    img_1.onload = function () {
                        resolve(img_1);
                    };
                    img_1.src = canvas.toDataURL();
                }
                else {
                    resolve(image);
                }
            });
        });
    };
    NgxPicaExifService = __decorate([
        Injectable()
    ], NgxPicaExifService);
    return NgxPicaExifService;
}());

var NgxPicaService = /** @class */ (function () {
    function NgxPicaService(_ngxPicaExifService) {
        this._ngxPicaExifService = _ngxPicaExifService;
        this.picaResizer = new Pica();
        this.MAX_STEPS = 20;
        if (!this.picaResizer || !this.picaResizer.resize) {
            this.picaResizer = new window.Pica();
        }
    }
    NgxPicaService.prototype.resizeImages = function (files, width, height, options) {
        var _this = this;
        var resizedImage = new Subject();
        var totalFiles = files.length;
        if (totalFiles > 0) {
            var nextFile_1 = new Subject();
            var index_1 = 0;
            var subscription_1 = nextFile_1
                .pipe(switchMap(function (file) { return _this.resizeImage(file, width, height, options); }))
                .subscribe(function (imageResized) {
                index_1++;
                resizedImage.next(imageResized);
                if (index_1 < totalFiles) {
                    nextFile_1.next(files[index_1]);
                }
                else {
                    resizedImage.complete();
                    subscription_1.unsubscribe();
                }
            }, function (err) {
                var ngxPicaError = {
                    file: files[index_1],
                    err: err
                };
                resizedImage.error(ngxPicaError);
            });
            nextFile_1.next(files[index_1]);
        }
        else {
            var ngxPicaError = {
                err: NgxPicaErrorType.NO_FILES_RECEIVED
            };
            resizedImage.error(ngxPicaError);
            resizedImage.complete();
        }
        return resizedImage.asObservable();
    };
    NgxPicaService.prototype.resizeImage = function (file, width, height, options) {
        var _this = this;
        var resizedImage = new Subject();
        var originCanvas = document.createElement('canvas');
        var ctx = originCanvas.getContext('2d');
        var img = new Image();
        var reader = new FileReader();
        if (!options) {
            options = {
                exifOptions: {
                    forceExifOrientation: true
                }
            };
        }
        if (ctx) {
            reader.addEventListener('load', function (event) {
                img.onerror = function (err) {
                    resizedImage.error({ err: NgxPicaErrorType.READ_ERROR, file: file, original_error: err });
                };
                img.onload = function () {
                    _this.processImageExifOptions(img, options.exifOptions)
                        .then(function (orientedImage) {
                        originCanvas.width = orientedImage.width;
                        originCanvas.height = orientedImage.height;
                        ctx.drawImage(orientedImage, 0, 0);
                        var imageData = ctx.getImageData(0, 0, orientedImage.width, orientedImage.height);
                        if (options && options.aspectRatio && options.aspectRatio.keepAspectRatio) {
                            var ratio = 0;
                            if (options.aspectRatio.forceMinDimensions) {
                                ratio = Math.max(width / imageData.width, height / imageData.height);
                            }
                            else {
                                ratio = Math.min(width / imageData.width, height / imageData.height);
                            }
                            width = Math.round(imageData.width * ratio);
                            height = Math.round(imageData.height * ratio);
                        }
                        var destinationCanvas = document.createElement('canvas');
                        destinationCanvas.width = width;
                        destinationCanvas.height = height;
                        _this.picaResize(file, originCanvas, destinationCanvas, options)
                            .catch(function (err) { return resizedImage.error(err); })
                            .then(function (imgResized) {
                            resizedImage.next(imgResized);
                            resizedImage.complete();
                        });
                    })
                        .catch(function (err) {
                        resizedImage.error({ err: NgxPicaErrorType.READ_ERROR, file: file, original_error: err });
                    });
                };
                img.src = reader.result;
            });
            reader.readAsDataURL(file);
        }
        else {
            resizedImage.error(NgxPicaErrorType.CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED);
        }
        return resizedImage.asObservable();
    };
    NgxPicaService.prototype.compressImages = function (files, sizeInMB, options) {
        var _this = this;
        var compressedImage = new Subject();
        var totalFiles = files.length;
        if (totalFiles > 0) {
            var nextFile_2 = new Subject();
            var index_2 = 0;
            var subscription_2 = nextFile_2
                .pipe(switchMap(function (file) { return _this.compressImage(file, sizeInMB, options); }))
                .subscribe(function (imageCompressed) {
                index_2++;
                compressedImage.next(imageCompressed);
                if (index_2 < totalFiles) {
                    nextFile_2.next(files[index_2]);
                }
                else {
                    compressedImage.complete();
                    subscription_2.unsubscribe();
                }
            }, function (err) {
                var ngxPicaError = {
                    file: files[index_2],
                    err: err
                };
                compressedImage.error(ngxPicaError);
            });
            nextFile_2.next(files[index_2]);
        }
        else {
            var ngxPicaError = {
                err: NgxPicaErrorType.NO_FILES_RECEIVED
            };
            compressedImage.error(ngxPicaError);
            compressedImage.complete();
        }
        return compressedImage.asObservable();
    };
    NgxPicaService.prototype.compressImage = function (file, sizeInMB, options) {
        var _this = this;
        var compressedImage = new Subject();
        if (this.bytesToMB(file.size) <= sizeInMB) {
            setTimeout(function () {
                compressedImage.next(file);
                compressedImage.complete();
            });
        }
        else {
            var originCanvas_1 = document.createElement('canvas');
            var ctx_1 = originCanvas_1.getContext('2d');
            var img_1 = new Image();
            var reader_1 = new FileReader();
            if (!options) {
                options = {
                    exifOptions: {
                        forceExifOrientation: true
                    }
                };
            }
            if (ctx_1) {
                reader_1.addEventListener('load', function (event) {
                    img_1.onload = function () {
                        _this.processImageExifOptions(img_1, options.exifOptions)
                            .then(function (orientedImage) {
                            originCanvas_1.width = orientedImage.width;
                            originCanvas_1.height = orientedImage.height;
                            ctx_1.drawImage(orientedImage, 0, 0);
                            _this.getCompressedImage(originCanvas_1, file.type, 1, sizeInMB, 0)
                                .catch(function (err) { return compressedImage.error(err); })
                                .then(function (blob) {
                                var imgCompressed = _this.blobToFile(blob, file.name, file.type, new Date().getTime());
                                compressedImage.next(imgCompressed);
                                compressedImage.complete();
                            });
                        });
                    };
                    img_1.src = reader_1.result;
                });
                reader_1.readAsDataURL(file);
            }
            else {
                compressedImage.error(NgxPicaErrorType.CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED);
            }
        }
        return compressedImage.asObservable();
    };
    NgxPicaService.prototype.processImageExifOptions = function (img, exifOptions) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (exifOptions.forceExifOrientation) {
                _this._ngxPicaExifService.getExifOrientedImage(img)
                    .then(function (orientedImage) { return resolve(orientedImage); })
                    .catch(function (err) { return reject(err); });
            }
            else {
                resolve(img);
            }
        });
    };
    NgxPicaService.prototype.getCompressedImage = function (canvas, type, quality, sizeInMB, step) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.picaResizer.toBlob(canvas, type, quality)
                .catch(function (err) { return reject(err); })
                .then(function (blob) {
                _this.checkCompressedImageSize(canvas, blob, quality, sizeInMB, step)
                    .catch(function (err) { return reject(err); })
                    .then(function (compressedBlob) {
                    resolve(compressedBlob);
                });
            });
        });
    };
    NgxPicaService.prototype.checkCompressedImageSize = function (canvas, blob, quality, sizeInMB, step) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (step > _this.MAX_STEPS) {
                reject(NgxPicaErrorType.NOT_BE_ABLE_TO_COMPRESS_ENOUGH);
            }
            else if (_this.bytesToMB(blob.size) < sizeInMB) {
                resolve(blob);
            }
            else {
                var newQuality = quality - (quality * 0.1);
                var newStep = step + 1;
                // recursively compression
                resolve(_this.getCompressedImage(canvas, blob.type, newQuality, sizeInMB, newStep));
            }
        });
    };
    NgxPicaService.prototype.picaResize = function (file, from, to, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.picaResizer.resize(from, to, options)
                .catch(function (err) { return reject(err); })
                .then(function (resizedCanvas) { return _this.picaResizer.toBlob(resizedCanvas, file.type); })
                .then(function (blob) {
                var fileResized = _this.blobToFile(blob, file.name, file.type, new Date().getTime());
                resolve(fileResized);
            });
        });
    };
    NgxPicaService.prototype.blobToFile = function (blob, name, type, lastModified) {
        return Object.assign(new Blob([blob], { type: type }), { name: name, lastModified: lastModified });
    };
    NgxPicaService.prototype.bytesToMB = function (bytes) {
        return bytes / 1048576;
    };
    NgxPicaService.ctorParameters = function () { return [
        { type: NgxPicaExifService }
    ]; };
    NgxPicaService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [NgxPicaExifService])
    ], NgxPicaService);
    return NgxPicaService;
}());

var NgxPicaImageService = /** @class */ (function () {
    function NgxPicaImageService() {
        this.imageExtensions = [
            'ase',
            'art',
            'bmp',
            'blp',
            'cd5',
            'cit',
            'cpt',
            'cr2',
            'cut',
            'dds',
            'dib',
            'djvu',
            'egt',
            'exif',
            'gif',
            'gpl',
            'grf',
            'icns',
            'ico',
            'iff',
            'jng',
            'jpeg',
            'jpg',
            'jfif',
            'jp2',
            'jps',
            'lbm',
            'max',
            'miff',
            'mng',
            'msp',
            'nitf',
            'ota',
            'pbm',
            'pc1',
            'pc2',
            'pc3',
            'pcf',
            'pcx',
            'pdn',
            'pgm',
            'PI1',
            'PI2',
            'PI3',
            'pict',
            'pct',
            'pnm',
            'pns',
            'ppm',
            'psb',
            'psd',
            'pdd',
            'psp',
            'px',
            'pxm',
            'pxr',
            'qfx',
            'raw',
            'rle',
            'sct',
            'sgi',
            'rgb',
            'int',
            'bw',
            'tga',
            'tiff',
            'tif',
            'vtf',
            'xbm',
            'xcf',
            'xpm',
            '3dv',
            'amf',
            'ai',
            'awg',
            'cgm',
            'cdr',
            'cmx',
            'dxf',
            'e2d',
            'egt',
            'eps',
            'fs',
            'gbr',
            'odg',
            'svg',
            'stl',
            'vrml',
            'x3d',
            'sxd',
            'v2d',
            'vnd',
            'wmf',
            'emf',
            'art',
            'xar',
            'png',
            'webp',
            'jxr',
            'hdp',
            'wdp',
            'cur',
            'ecw',
            'iff',
            'lbm',
            'liff',
            'nrrd',
            'pam',
            'pcx',
            'pgf',
            'sgi',
            'rgb',
            'rgba',
            'bw',
            'int',
            'inta',
            'sid',
            'ras',
            'sun',
            'tga'
        ];
    }
    NgxPicaImageService.prototype.isImage = function (file) {
        var fileExtension = file.name.toLowerCase().substr(file.name.lastIndexOf('.') + 1);
        return (this.imageExtensions.indexOf(fileExtension) !== -1);
    };
    NgxPicaImageService = __decorate([
        Injectable()
    ], NgxPicaImageService);
    return NgxPicaImageService;
}());

var NgxPicaModule = /** @class */ (function () {
    function NgxPicaModule() {
    }
    NgxPicaModule = __decorate([
        NgModule({
            providers: [
                { provide: NgxPicaService, useClass: NgxPicaService },
                { provide: NgxPicaExifService, useClass: NgxPicaExifService },
                { provide: NgxPicaImageService, useClass: NgxPicaImageService },
            ]
        })
    ], NgxPicaModule);
    return NgxPicaModule;
}());

/*
 * Public API Surface of ngx-pica
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxPicaImageService, NgxPicaModule, NgxPicaService, NgxPicaExifService as ɵa };
//# sourceMappingURL=digitalascetic-ngx-pica.js.map
