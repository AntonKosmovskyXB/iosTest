import { Directive, Input, Output, EventEmitter, HostListener } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export class ColorPickerInputDirective {
    constructor() {
        this.inputChange = new EventEmitter();
    }
    inputChanges(event) {
        const element = event.target || event.srcElement;
        const value = element.value;
        const numeric = parseFloat(value);
        if (!isNaN(numeric) && numeric >= parseInt(this.min, 10) &&
            numeric <= parseInt(this.max, 10)) {
            this.inputChange.emit(numeric);
        }
    }
}
ColorPickerInputDirective.ɵfac = function ColorPickerInputDirective_Factory(t) { return new (t || ColorPickerInputDirective)(); };
ColorPickerInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColorPickerInputDirective, selectors: [["", "inputChange", ""]], hostBindings: function ColorPickerInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function ColorPickerInputDirective_input_HostBindingHandler($event) { return ctx.inputChanges($event); });
    } }, inputs: { min: "min", max: "max" }, outputs: { inputChange: "inputChange" } });
ColorPickerInputDirective.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    inputChange: [{ type: Output }],
    inputChanges: [{ type: HostListener, args: ['input', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorPickerInputDirective, [{
        type: Directive,
        args: [{
                selector: '[inputChange]'
            }]
    }], function () { return []; }, { inputChange: [{
            type: Output
        }], inputChanges: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3ItcGlja2VyLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaXBsYWIvbmd4LWNvbG9yLXBpY2tlci9zcmMvbGliL2RpcmVjdGl2ZXMvY29sb3ItcGlja2VyLWlucHV0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFNckYsTUFBTSxPQUFPLHlCQUF5QjtBQUN0QyxJQUpBO0FBQ0csUUFVUSxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7QUFDcEQsSUFZQSxDQUFDO0FBQ0QsSUFYVyxZQUFZLENBQUMsS0FBVTtBQUFJLFFBQzlCLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUEwQixJQUFJLEtBQUssQ0FBQyxVQUE4QixDQUFDO0FBQ2pHLFFBQVEsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUNwQyxRQUNRLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQyxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQztBQUNoRSxZQUFZLE9BQU8sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUMvQyxZQUFZLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzNDLFNBQVM7QUFDVCxJQUFJLENBQUM7QUFDTDtxREF4QkMsU0FBUyxTQUFDLGtCQUNQLFFBQVEsRUFBRSxlQUFlLGNBQzVCOzs7d0ZBQ0k7QUFBQztBQUNJLGtCQUFMLEtBQUs7QUFDUixrQkFFRyxLQUFLO0FBQ1IsMEJBRUcsTUFBTTtBQUNULDJCQUVHLFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUM7QUFDakM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFqQkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFNQSxBQUFBLEFBQUEsQUFBQSxBQUhBLEFBV0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFhQSxBQUFBLEFBVkEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUF2QkEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUVBLEFBQUEsQUFHQSxBQUFBLEFBR0EsQUFBQSxBQUdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1tpbnB1dENoYW5nZV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDb2xvclBpY2tlcklucHV0RGlyZWN0aXZlIHtcclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgbWluOiBzdHJpbmc7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBtYXg6IHN0cmluZztcclxuXHJcbiAgICBAT3V0cHV0KClcclxuICAgIHB1YmxpYyBpbnB1dENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQnXSlcclxuICAgIHB1YmxpYyBpbnB1dENoYW5nZXMoZXZlbnQ6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCB8fCBldmVudC5zcmNFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xyXG5cclxuICAgICAgICBjb25zdCBudW1lcmljID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc05hTihudW1lcmljKSAmJiBudW1lcmljID49IHBhcnNlSW50KHRoaXMubWluLCAxMCkgJiZcclxuICAgICAgICAgICAgbnVtZXJpYyA8PSBwYXJzZUludCh0aGlzLm1heCwgMTApKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2UuZW1pdChudW1lcmljKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19