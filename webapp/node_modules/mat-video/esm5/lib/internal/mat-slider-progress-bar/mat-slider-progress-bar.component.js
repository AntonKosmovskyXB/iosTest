/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input, ElementRef, ChangeDetectorRef, ChangeDetectionStrategy, Optional, Attribute } from "@angular/core";
import { MatSlider, MAT_SLIDER_VALUE_ACCESSOR } from "@angular/material/slider";
import { FocusMonitor } from "@angular/cdk/a11y";
import { Directionality } from "@angular/cdk/bidi";
/**
 * Counter used to generate unique IDs for progress bars.
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/a11y';
import * as ɵngcc2 from '@angular/cdk/bidi';
import * as ɵngcc3 from '@angular/common';
var sliderprogressbarId = 0;
var MatSliderProgressBarComponent = /** @class */ (function (_super) {
    tslib_1.__extends(MatSliderProgressBarComponent, _super);
    function MatSliderProgressBarComponent(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {
        var _this = _super.call(this, elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) || this;
        _this.mode = "buffer";
        _this.value = 0;
        _this.pBufferValue = 0;
        /**
         * The id of the progress bar.
         */
        _this.sliderprogressbarId = "mat-slider-progress-bar-" + sliderprogressbarId++;
        _this.tabIndex = parseInt(tabIndex, 10) || 0;
        return _this;
    }
    Object.defineProperty(MatSliderProgressBarComponent.prototype, "bufferValue", {
        /** Buffer value of the progress bar. Defaults to zero. */
        get: /**
         * Buffer value of the progress bar. Defaults to zero.
         * @return {?}
         */
        function () {
            return this.pBufferValue;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this.pBufferValue = clamp(v || 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatSliderProgressBarComponent.prototype, "_trackBufferStyles", {
        /** CSS styles for the track fill element. */
        get: /**
         * CSS styles for the track fill element.
         * @return {?}
         */
        function () {
            if (this.mode === "buffer") {
                /** @type {?} */
                var axis = this.vertical ? "Y" : "X";
                return {
                    transform: "translate" + axis + "(0px) scale" + axis + "(" + this.pBufferValue / 100 + ")"
                };
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @nocollapse */
    MatSliderProgressBarComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FocusMonitor },
        { type: ChangeDetectorRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: String, decorators: [{ type: Attribute, args: ["tabindex",] }] }
    ]; };
    MatSliderProgressBarComponent.propDecorators = {
        mode: [{ type: Input }],
        value: [{ type: Input }],
        bufferValue: [{ type: Input }]
    };
MatSliderProgressBarComponent.ɵfac = function MatSliderProgressBarComponent_Factory(t) { return new (t || MatSliderProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵinjectAttribute("tabindex")); };
MatSliderProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSliderProgressBarComponent, selectors: [["mat-slider-progress-bar"]], hostAttrs: ["role", "slider", 1, "mat-slider"], hostVars: 24, hostBindings: function MatSliderProgressBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function MatSliderProgressBarComponent_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function MatSliderProgressBarComponent_blur_HostBindingHandler() { return ctx._onBlur(); })("click", function MatSliderProgressBarComponent_click_HostBindingHandler($event) { return ctx["_onClick"] ? ctx["_onClick"]($event) : null; })("mousedown", function MatSliderProgressBarComponent_mousedown_HostBindingHandler($event) { return ctx["_onMousedown"] ? ctx["_onMousedown"]($event) : null; })("keydown", function MatSliderProgressBarComponent_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })("keyup", function MatSliderProgressBarComponent_keyup_HostBindingHandler() { return ctx._onKeyup(); })("mouseenter", function MatSliderProgressBarComponent_mouseenter_HostBindingHandler() { return ctx._onMouseenter(); })("slide", function MatSliderProgressBarComponent_slide_HostBindingHandler($event) { return ctx._onSlide($event); })("slideend", function MatSliderProgressBarComponent_slideend_HostBindingHandler() { return ctx._onSlideEnd(); })("slidestart", function MatSliderProgressBarComponent_slidestart_HostBindingHandler($event) { return ctx._onSlideStart($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("aria-valuemax", ctx.max)("aria-valuemin", ctx.min)("aria-valuenow", ctx.value)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵclassProp("mat-slider-disabled", ctx.disabled)("mat-slider-has-ticks", ctx.tickInterval)("mat-slider-horizontal", !ctx.vertical)("mat-slider-axis-inverted", ctx._invertAxis)("mat-slider-sliding", ctx._isSliding)("mat-slider-thumb-label-showing", ctx.thumbLabel)("mat-slider-vertical", ctx.vertical)("mat-slider-min-value", ctx._isMinValue)("mat-slider-hide-last-tick", ctx.disabled || ctx._isMinValue && ctx._thumbGap && ctx._invertAxis);
    } }, inputs: { disabled: "disabled", color: "color", tabIndex: "tabIndex", bufferValue: "bufferValue", mode: "mode", value: "value" }, features: [ɵngcc0.ɵɵProvidersFeature([MAT_SLIDER_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 18, vars: 8, consts: [[1, "mat-slider-wrapper"], ["sliderWrapper", ""], [1, "mat-slider-track-wrapper"], ["width", "100%", "height", "2", "focusable", "false", 1, "mat-slider-progress-background"], ["x", "2.5", "y", "0", "width", "5", "height", "2.5", "patternUnits", "userSpaceOnUse", 3, "id"], ["cx", "1.25", "cy", "1.25", "r", "1.25"], ["width", "100%", "height", "100%"], [1, "mat-slider-track-fill", "mat-slider-track-buffer", 3, "ngStyle"], [1, "mat-slider-track-fill", 3, "ngStyle"], [1, "mat-slider-ticks-container", 3, "ngStyle"], [1, "mat-slider-ticks", 3, "ngStyle"], [1, "mat-slider-thumb-container", 3, "ngStyle"], [1, "mat-slider-focus-ring"], [1, "mat-slider-thumb"], [1, "mat-slider-thumb-label"], [1, "mat-slider-thumb-label-text"]], template: function MatSliderProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelementStart(4, "defs");
        ɵngcc0.ɵɵelementStart(5, "pattern", 4);
        ɵngcc0.ɵɵelement(6, "circle", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "rect", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(8, "div", 7);
        ɵngcc0.ɵɵelement(9, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelement(11, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 11);
        ɵngcc0.ɵɵelement(13, "div", 12);
        ɵngcc0.ɵɵelement(14, "div", 13);
        ɵngcc0.ɵɵelementStart(15, "div", 14);
        ɵngcc0.ɵɵelementStart(16, "span", 15);
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("id", ctx.sliderprogressbarId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("fill", "url(#" + ctx.sliderprogressbarId + ")");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackBufferStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackFillStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksContainerStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._thumbContainerStyles);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.displayValue);
    } }, directives: [ɵngcc3.NgStyle], styles: ["[_nghost-%COMP%]{width:100%}.mat-slider-progress-background[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer[_ngcontent-%COMP%]{background-color:#d3d3d3!important}.mat-slider-thumb[_ngcontent-%COMP%]{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}[_nghost-%COMP%]:hover   .mat-slider-thumb[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .2s linear}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSliderProgressBarComponent, [{
        type: Component,
        args: [{
                selector: "mat-slider-progress-bar",
                template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\r\n  <div class=\"mat-slider-track-wrapper\">\r\n    <svg width=\"100%\" height=\"2\" focusable=\"false\" class=\"mat-slider-progress-background\">\r\n      <defs>\r\n        <pattern [id]=\"sliderprogressbarId\" x=\"2.5\" y=\"0\" width=\"5\" height=\"2.5\" patternUnits=\"userSpaceOnUse\">\r\n          <circle cx=\"1.25\" cy=\"1.25\" r=\"1.25\" />\r\n        </pattern>\r\n      </defs>\r\n      <rect [attr.fill]=\"'url(#' + sliderprogressbarId + ')'\" width=\"100%\" height=\"100%\" />\r\n    </svg>\r\n    <div class=\"mat-slider-track-fill mat-slider-track-buffer\" [ngStyle]=\"_trackBufferStyles\"></div>\r\n    <div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\">\r\n    <div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div>\r\n  </div>\r\n  <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\">\r\n    <div class=\"mat-slider-focus-ring\"></div>\r\n    <div class=\"mat-slider-thumb\"></div>\r\n    <div class=\"mat-slider-thumb-label\">\r\n      <span class=\"mat-slider-thumb-label-text\">{{ displayValue }}</span>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                providers: [MAT_SLIDER_VALUE_ACCESSOR],
                host: {
                    "(focus)": "_onFocus()",
                    "(blur)": "_onBlur()",
                    "(click)": 'this["_onClick"] ? this["_onClick"]($event) : null',
                    // Angular 5/6 support
                    "(mousedown)": 'this["_onMousedown"] ? this["_onMousedown"]($event) : null',
                    // Angular 7 support
                    "(keydown)": "_onKeydown($event)",
                    "(keyup)": "_onKeyup()",
                    "(mouseenter)": "_onMouseenter()",
                    "(slide)": "_onSlide($event)",
                    "(slideend)": "_onSlideEnd()",
                    "(slidestart)": "_onSlideStart($event)",
                    class: "mat-slider",
                    role: "slider",
                    "[tabIndex]": "tabIndex",
                    "[attr.aria-disabled]": "disabled",
                    "[attr.aria-valuemax]": "max",
                    "[attr.aria-valuemin]": "min",
                    "[attr.aria-valuenow]": "value",
                    "[attr.aria-orientation]": 'vertical ? "vertical" : "horizontal"',
                    "[class.mat-slider-disabled]": "disabled",
                    "[class.mat-slider-has-ticks]": "tickInterval",
                    "[class.mat-slider-horizontal]": "!vertical",
                    "[class.mat-slider-axis-inverted]": "_invertAxis",
                    "[class.mat-slider-sliding]": "_isSliding",
                    "[class.mat-slider-thumb-label-showing]": "thumbLabel",
                    "[class.mat-slider-vertical]": "vertical",
                    "[class.mat-slider-min-value]": "_isMinValue",
                    "[class.mat-slider-hide-last-tick]": "disabled || _isMinValue && _thumbGap && _invertAxis"
                },
                inputs: ["disabled", "color", "tabIndex"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.FocusMonitor }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.Directionality, decorators: [{
                type: Optional
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ["tabindex"]
            }] }]; }, { bufferValue: [{
            type: Input
        }], mode: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
    return MatSliderProgressBarComponent;
}(MatSlider));
export { MatSliderProgressBarComponent };
if (false) {
    /** @type {?} */
    MatSliderProgressBarComponent.prototype.mode;
    /** @type {?} */
    MatSliderProgressBarComponent.prototype.value;
    /**
     * @type {?}
     * @private
     */
    MatSliderProgressBarComponent.prototype.pBufferValue;
    /**
     * The id of the progress bar.
     * @type {?}
     */
    MatSliderProgressBarComponent.prototype.sliderprogressbarId;
}
/**
 * Clamps a value to be between two numbers, by default 0 and 100.
 * @param {?} v
 * @param {?=} min
 * @param {?=} max
 * @return {?}
 */
function clamp(v, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 100; }
    return Math.max(min, Math.min(max, v));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNsaWRlci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyJuZzovbWF0LXZpZGVvL2xpYi9pbnRlcm5hbC9tYXQtc2xpZGVyLXByb2dyZXNzLWJhci9tYXQtc2xpZGVyLXByb2dyZXNzLWJhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsdUJBQXVCLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5SCxPQUFPLEVBQUUsU0FBUyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDaEYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRDtBQUNHO0FBQTBEO0FBQ2pEOzs7OztBQUFJLElBQVosbUJBQW1CLEdBQUcsQ0FBQztBQUUzQjtBQUVtQixJQW1DZ0MseURBQVM7QUFBQyxJQWdCM0QsdUNBQ0UsVUFBc0IsRUFDdEIsWUFBMEIsRUFDMUIsaUJBQW9DLEVBQ3hCLEdBQW1CLEVBQ1IsUUFBZ0I7QUFDeEMsUUFORCxZQU9FLGtCQUFNLFVBQVUsRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUVsRTtBQUNILFFBekJXLFVBQUksR0FBRyxRQUFRLENBQUM7QUFDM0IsUUFBVyxXQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLFFBUVUsa0JBQVksR0FBRyxDQUFDLENBQUM7QUFDM0I7QUFDVztBQUNFO0FBQVksUUFBdkIseUJBQW1CLEdBQUcsNkJBQTJCLG1CQUFtQixFQUFJLENBQUM7QUFDM0UsUUFTSSxLQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0FB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QUEsQUFBQSxBQUdBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBVUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFyQkEsQUFDQSxBQUFBLEFBRkEsQUFBQSxBQUNBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFIQSxBQXFCQSxBQUFBLEFBQUEsQUFEQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUFBLEFBeEVBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQTVDQSxBQUFBLEFBRUEsQUFBQSxBQUZBLEFBQUEsQUFHQSxBQUFBLEFBOERBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQXBCQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFnQ0EsQUFBQSxBQUFBLEFBekVBLEFBcUNBLEFBQUEsQUFvQ0EsQUFwQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBU0EsQUFBQSxBQUdBLEFBQUEsQUF5QkEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIE9wdGlvbmFsLCBBdHRyaWJ1dGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBNYXRTbGlkZXIsIE1BVF9TTElERVJfVkFMVUVfQUNDRVNTT1IgfSBmcm9tIFwiQGFuZ3VsYXIvbWF0ZXJpYWwvc2xpZGVyXCI7XHJcbmltcG9ydCB7IEZvY3VzTW9uaXRvciB9IGZyb20gXCJAYW5ndWxhci9jZGsvYTExeVwiO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gXCJAYW5ndWxhci9jZGsvYmlkaVwiO1xyXG5cclxuLyoqIENvdW50ZXIgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzIGZvciBwcm9ncmVzcyBiYXJzLiAqL1xyXG5sZXQgc2xpZGVycHJvZ3Jlc3NiYXJJZCA9IDA7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogXCJtYXQtc2xpZGVyLXByb2dyZXNzLWJhclwiLFxyXG4gIHRlbXBsYXRlVXJsOiBcIi4vbWF0LXNsaWRlci1wcm9ncmVzcy1iYXIuY29tcG9uZW50Lmh0bWxcIixcclxuICBzdHlsZVVybHM6IFtcIi4vbWF0LXNsaWRlci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LnNjc3NcIl0sXHJcbiAgcHJvdmlkZXJzOiBbTUFUX1NMSURFUl9WQUxVRV9BQ0NFU1NPUl0sXHJcbiAgaG9zdDoge1xyXG4gICAgXCIoZm9jdXMpXCI6IFwiX29uRm9jdXMoKVwiLFxyXG4gICAgXCIoYmx1cilcIjogXCJfb25CbHVyKClcIixcclxuICAgIFwiKGNsaWNrKVwiOiAndGhpc1tcIl9vbkNsaWNrXCJdID8gdGhpc1tcIl9vbkNsaWNrXCJdKCRldmVudCkgOiBudWxsJywgLy8gQW5ndWxhciA1LzYgc3VwcG9ydFxyXG4gICAgXCIobW91c2Vkb3duKVwiOiAndGhpc1tcIl9vbk1vdXNlZG93blwiXSA/IHRoaXNbXCJfb25Nb3VzZWRvd25cIl0oJGV2ZW50KSA6IG51bGwnLCAvLyBBbmd1bGFyIDcgc3VwcG9ydFxyXG4gICAgXCIoa2V5ZG93bilcIjogXCJfb25LZXlkb3duKCRldmVudClcIixcclxuICAgIFwiKGtleXVwKVwiOiBcIl9vbktleXVwKClcIixcclxuICAgIFwiKG1vdXNlZW50ZXIpXCI6IFwiX29uTW91c2VlbnRlcigpXCIsXHJcbiAgICBcIihzbGlkZSlcIjogXCJfb25TbGlkZSgkZXZlbnQpXCIsXHJcbiAgICBcIihzbGlkZWVuZClcIjogXCJfb25TbGlkZUVuZCgpXCIsXHJcbiAgICBcIihzbGlkZXN0YXJ0KVwiOiBcIl9vblNsaWRlU3RhcnQoJGV2ZW50KVwiLFxyXG4gICAgY2xhc3M6IFwibWF0LXNsaWRlclwiLFxyXG4gICAgcm9sZTogXCJzbGlkZXJcIixcclxuICAgIFwiW3RhYkluZGV4XVwiOiBcInRhYkluZGV4XCIsXHJcbiAgICBcIlthdHRyLmFyaWEtZGlzYWJsZWRdXCI6IFwiZGlzYWJsZWRcIixcclxuICAgIFwiW2F0dHIuYXJpYS12YWx1ZW1heF1cIjogXCJtYXhcIixcclxuICAgIFwiW2F0dHIuYXJpYS12YWx1ZW1pbl1cIjogXCJtaW5cIixcclxuICAgIFwiW2F0dHIuYXJpYS12YWx1ZW5vd11cIjogXCJ2YWx1ZVwiLFxyXG4gICAgXCJbYXR0ci5hcmlhLW9yaWVudGF0aW9uXVwiOiAndmVydGljYWwgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIicsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLWRpc2FibGVkXVwiOiBcImRpc2FibGVkXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLWhhcy10aWNrc11cIjogXCJ0aWNrSW50ZXJ2YWxcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItaG9yaXpvbnRhbF1cIjogXCIhdmVydGljYWxcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZF1cIjogXCJfaW52ZXJ0QXhpc1wiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1zbGlkaW5nXVwiOiBcIl9pc1NsaWRpbmdcIixcclxuICAgIFwiW2NsYXNzLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZ11cIjogXCJ0aHVtYkxhYmVsXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLXZlcnRpY2FsXVwiOiBcInZlcnRpY2FsXCIsXHJcbiAgICBcIltjbGFzcy5tYXQtc2xpZGVyLW1pbi12YWx1ZV1cIjogXCJfaXNNaW5WYWx1ZVwiLFxyXG4gICAgXCJbY2xhc3MubWF0LXNsaWRlci1oaWRlLWxhc3QtdGlja11cIjogXCJkaXNhYmxlZCB8fCBfaXNNaW5WYWx1ZSAmJiBfdGh1bWJHYXAgJiYgX2ludmVydEF4aXNcIlxyXG4gIH0sXHJcbiAgaW5wdXRzOiBbXCJkaXNhYmxlZFwiLCBcImNvbG9yXCIsIFwidGFiSW5kZXhcIl0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hdFNsaWRlclByb2dyZXNzQmFyQ29tcG9uZW50IGV4dGVuZHMgTWF0U2xpZGVyIHtcclxuICBASW5wdXQoKSBtb2RlID0gXCJidWZmZXJcIjtcclxuICBASW5wdXQoKSB2YWx1ZSA9IDA7XHJcbiAgLyoqIEJ1ZmZlciB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiBEZWZhdWx0cyB0byB6ZXJvLiAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IGJ1ZmZlclZhbHVlKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5wQnVmZmVyVmFsdWU7XHJcbiAgfVxyXG4gIHNldCBidWZmZXJWYWx1ZSh2OiBudW1iZXIpIHtcclxuICAgIHRoaXMucEJ1ZmZlclZhbHVlID0gY2xhbXAodiB8fCAwKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBwQnVmZmVyVmFsdWUgPSAwO1xyXG5cclxuICAvKiogVGhlIGlkIG9mIHRoZSBwcm9ncmVzcyBiYXIuICovXHJcbiAgc2xpZGVycHJvZ3Jlc3NiYXJJZCA9IGBtYXQtc2xpZGVyLXByb2dyZXNzLWJhci0ke3NsaWRlcnByb2dyZXNzYmFySWQrK31gO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICBmb2N1c01vbml0b3I6IEZvY3VzTW9uaXRvcixcclxuICAgIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgIEBPcHRpb25hbCgpIGRpcjogRGlyZWN0aW9uYWxpdHksXHJcbiAgICBAQXR0cmlidXRlKFwidGFiaW5kZXhcIikgdGFiSW5kZXg6IHN0cmluZ1xyXG4gICkge1xyXG4gICAgc3VwZXIoZWxlbWVudFJlZiwgZm9jdXNNb25pdG9yLCBjaGFuZ2VEZXRlY3RvclJlZiwgZGlyLCB0YWJJbmRleCk7XHJcbiAgICB0aGlzLnRhYkluZGV4ID0gcGFyc2VJbnQodGFiSW5kZXgsIDEwKSB8fCAwO1xyXG4gIH1cclxuXHJcbiAgLyoqIENTUyBzdHlsZXMgZm9yIHRoZSB0cmFjayBmaWxsIGVsZW1lbnQuICovXHJcbiAgZ2V0IF90cmFja0J1ZmZlclN0eWxlcygpOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcclxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwiYnVmZmVyXCIpIHtcclxuICAgICAgY29uc3QgYXhpcyA9IHRoaXMudmVydGljYWwgPyBcIllcIiA6IFwiWFwiO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSR7YXhpc30oMHB4KSBzY2FsZSR7YXhpc30oJHt0aGlzLnBCdWZmZXJWYWx1ZSAvIDEwMH0pYFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqIENsYW1wcyBhIHZhbHVlIHRvIGJlIGJldHdlZW4gdHdvIG51bWJlcnMsIGJ5IGRlZmF1bHQgMCBhbmQgMTAwLiAqL1xyXG5mdW5jdGlvbiBjbGFtcCh2OiBudW1iZXIsIG1pbiA9IDAsIG1heCA9IDEwMCkge1xyXG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdikpO1xyXG59XHJcbiJdfQ==